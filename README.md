# 基于JAVA CS远程监控系统软件的实现

# **摘  要**

近年来，网络技术的不断发展，为远程监控技术的发展创造了条件。远程监控系统软件越来越受到人们的重视，其实用性也毋庸质疑。基于JAVA C/S远程监控系统软件突破了空间的限制，使用者不用亲临，在自己的电脑面前就能轻松的实现对被监控端机器的监控。本系统采用Java网络编程和Java图形编程实现。笔者在开发过程中将网络技术与远程监控理论基础相结合，实现了以下功能：能连续获得被监控端机器屏幕变化；实现被监控端硬盘文件的上传、下载；实现对鼠标、键盘的模拟；实现在远程机器上执行任意DOS命令；远程关机、远程重启计算机，方便了用户监视和操作被监控端机器。本系统从系统需求分析、概要设计、详细设计到具体的编码实现和后期的代码优化、功能测试都严格遵循了软件工程的思想。 

**关键词：**远程监控；Java Robot；屏幕截取；Java Socket

# 1 系统需求分析及理论基础

## 1.1 系统功能需求

1．连续获得被控端机器屏幕变化。

2．实现被控端硬盘文件的上传、下载。

3．实现对鼠标、键盘的模拟。

4．实现在被控端机器上执行任意DOS命令。

5．远程关机、远程重启计算机。

## 1.2 其他需求

1．系统实用，界面操作简便。

2．被监控端自动隐藏运行。

被监控端将随电脑启动而自动运行，运行时默认无任何可见界面。

# 2 远程监控系统系统设计

## 2.1 系统总体结构设计和分析

本系统设计的方案为C/S模式，在主控端电脑上安装服务器端程序，在被监控端电脑上安装客户端程序。该系统的控制过程是先在主控端电脑上执行服务器程序，在命令收发过程中，主控端向被监控端配置的UDP端口发送命令，该命令是一个控制命令，要求被监控端来连接其开启的TCP端口和要求被监控端执行的操作，如果被监控端监听到该UDP命令，主动开启TCP端口向主控端发送连接请求。这样就建立了一个特殊的远程服务，然后通过这个远程服务，主控端使用各种远程控制功能发送远程控制命令，控制被监控端电脑中的各种应用程序运行。系统总体结构如图：

![](http://www.writebug.com/myres/static/uploads/2021/10/19/d1836aad33600a3d38b610bcc87c6bed.writebug)

图中把软件功能分解到通信的两个端点上，即客户端和服务器端，采用Client／Server模式。这样能提高设计的灵活性，易于系统的扩展。被监控端接受主控端命令，并处理命令，然后输出命令处理结果；主控端则提供交互界面及命令处理结果显示；数据交换通道的建立由双方的数据通信模块负责。从而实现点到点的直接控制监控，满足实时性要求。

### 2.1.1 主控端的主要功能模块

主控端包括的模块有：消息输入，命令处理结果显示模块，通信模块。消息输入模块负责将用户界面的事件传送到通信模块，通信模块将命令信息发送到被监控端；被监控端执行操作后返回的成功或失败信息交由主控端命令处理结果显示模块根据信息的格式进行显示。

 

### 2.1.2 被监控端的主要功能模块

被监控端包括的模块有：通信模块，命令处理模块。被监控端处于侦听状态，一旦接收到合法的连接请求，就开UDP端口，并开启命令接受线程，建立连接后，通过通信模块接收主控端发来的命令信息，经命令处理模块解释后，并将结果返回到主控端。

 

## 2.2 程序流程及分析

### 2.2.1 被监控端启动流程



在被监控端安装客户端程序，程序启动的时候，尝试开启UDP端口，如果防火墙或者杀毒软件阻止，尝试开启配置的其它UDP端口，如果都尝试完毕，启动失败。否则，将开启的UDP套接字传入，然后开启命令接收线程，目的是进行命令获取，并对获取的命令进行处理。然后将自己复制到自启动项，并改名为Explorer.jar. 流程如图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/9e6a9592d5fc26ec329a2d844a6acee5.writebug)

### 2.2.2 主控端启动流程

在主控端安装服务器程序，主控端首先启动其控制窗口类，初始化图形在主控端安装服务器程序，主控端首先启动其控制窗口类，初始化图形显示，然后用户输入被监控端的IP地址。接着主控端开启任意TCP端口，并向该IP配置的UDP端口发送初始化命令（命令格式为ordername:port），ordername

为命令名字，port为主控端打开的TCP端口号。主控端对开启的TCP端口进行监听，如果超时，连接失败。否则，主控端读取被监控端的状态对象，接着启动控制模块和屏幕监视模块。

流程如图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/6c1074cc1716b18699c8ca315f3f6a0e.writebug)

### 2.2.3 命令接收和处理流程

被监控端UDP端口启动成功后，就开始对该UDP端口进行监听，如果监听到有命令，就读取它，并判断命令是否有效，命令以ordername:port为格式，如果无效，返回继续读取命令，否则，调用相应的命令处理模块对命令进行处理，命令处理完后将处理结果返回给主控端。流程如图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/c4a625ab547a3414288fd1f546ab9fbb.writebug)

### 2.2.4 图形监视线程启动流程

主控端开启任意TCP端口，向被监控端的UDP端口发送“要求被监控端连接”的UDP命令，命令形式为screen：TCP Port。如果命令超时，命令执行失败，否则，如果被监视端来连接，生成Soket对象，从Soket中读取被监视端发送过来的图形对象，并将图象显示在画布上，每隔一定时间（若干秒），重新读取图象，更新画布显示，从而实现连续获得对方屏幕变化。流程如图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/886393b3a504755c2987acf47bf80900.writebug)

### 2.2.5 远程控制流程

被监控端收到主控端的UDP命令：control:TCP Port，获得主控端开放的TCP端口号。成功连接主控端的TCP端口后，并从中读取事件对象，接着对事件对象进行类型判断，如果是键盘事件，就对键盘事件重演；如果是鼠标事件，就对鼠标事件重演。接着判定控制套接是否关闭，如果关闭，控制结束。否则返回继续读取事件。流程如图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/561bf0fd8ee571a1b9f761285e1cd553.writebug)

### 2.2.6 文件上传流程

主控端开启任意TCP端口，向被监控端发送文件上传命令，命令格式为：fileup:TCP Port。如果命令超时，文件上传失败，否则，主控端读取文件数据并发送，发送过程中如果I/O错误，文件上传失败，否则，进行文件是否读取完判断，如果读取完，则上传成功，否则，继续读取文件数据。流程如图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/cce8314a55622fa245ff0913afd1dd73.writebug)

# 3 系统主要模块设计和具体功能实现

## 3.1 系统主要模块设计

### 3.1.1 消息输入，命令处理结果显示模块

主控端消息输入，显示模块的开发采用JAVA图形编程，利用模块化、通用性强的特点，实现远程监控中用户控制界面的编写。

### 3.1.2 通信模块实现

1．Socket编程

数据通信模块中的数据通道建立采用Socket编程。Socket支持TCP／IP协议网络通信的基本操作；它屏蔽了网络底层的通信细节，使编程简单；它对通信端点进行了抽象，提供发送和接收数据机制及打开、计算和关闭会话的能力。本项目中，客户端和服务器代表运行在Windows操作平台下，采用Java Socket来编程实现命令和数据信息的传输。

2．通信建立

服务器与客户端开始都必须调用socket()函数产生一个Socket套接字。由于让被监控端开TCP端口，很容易被防火墙和杀毒软件阻止，监控就难以完成。这里，我们在主控端开TCP端口，等待被监控端来主动连接，这样监控功能就能更顺利的开始。主控端首先创建一个ServerSocket对象，然后调用ServerSocket的方法accept实现监听。如果被监控端来访问，accept会返回一个socket对象，利用这个对象就可以很轻松的完成服务器和客户端的数据交换。只有被监控端有请求时才建立连接，建立连接后，客户端与服务器之间便可以双向传输数据。当得到socket对象后，主控端建立ObjectInputStream对象，被监控端建立ObjectOutputStream对象实现消息的接收和发送。完成通信后，调用ServerSocket和socket对象的close关闭套接字，结束通信。

主控端主要通信代码：

```java
ServerSocket server=NewRadomSocket.openNewPort(); //开启新端口
Socket socket=null;
server.setSoTimeout(Parameter.TCP_TIME_OUT); //设置超时
socket=server.accept(); //开启
ObjectInputStream readin=new ObjectInputStream(socket.getInputStream()); //封装流，准备读取一个对象
socket.close(); //关闭socket，结束通信

```

被监控端主要通信代码：

```java
Socket socket=new Socket(serverip, serverport);
ObjectOutputStream send=new ObjectOutputStream(socket.getOutputStream());//封装流
send.writeObject(cc); //发送
send.close(); //关闭流
socket.close(); //关闭套接

```

### 3.1.3 命令处理模块

命令处理模块的实现就是通过函数调用，调用各个命令处理类。在命令处理模块中，被监控端执行以下操作：发送自己的状态信息给主控端；建立图象传送；开启控制命令套接字；文件上传；文件下载；执行DOS命令，获取执行结果和错误流。

 

## 3.2 连续获得被监控端机器屏幕变化功能实现

### 3.2.1 比较几种屏幕截取方法

在Java远程监控过程中，我们要截取软件运行GUI界面，并将其保存到一个或一系列图像文件中。

目前，在Windows平台下，有关屏幕截取的工具软件有许多，比如：HyperCam等，当然还可以直接利用Windows操作系统支持的屏幕拷贝Print Screen键，将屏幕拷贝到剪贴板，在保存为图像文件。这些工具软件一定要屏幕截取者，在操作过程中要"精力集中"并且"伺机捕获"所需要的软件运行界面。事实上，有时候我们需要Java应用程序，自动对运行的GUI界面进行"拍照"，比如：一台计算机要获取网络上另一台计算机正在运行的GUI界面，要看看对方计算机上软件运行情况。这就需要在Java应用程序中，自动将运行的GUI界面保存到一个图像文件中，然后通过网络传输到另一台计算机上。而上述HyperCam等工具软件无法与我们的Java应用融合为一体。因此，我们需要在Java应用程序中编写一个屏幕"照相机"。

### 3.2.2 Java“屏幕照相机”的编写原理

"屏幕的截取"是比较接近操作系统底层的操作，在Windows平台下，该操作似乎成了VC、VB等语言开发的专利。事实上，"屏幕的截取"在Java应用程序中，及其简单。在Java JDK1.5.0 中提供了一个"机器人"Robot类。该类用于产生与本地操作系统有关的底层输入、测试应用程序运行或自动控制应用程序运行。Robot类提供了一个方法：.createScreenCapture（..）,可以直接将全屏幕或某个屏幕区域的像素拷贝到一个BufferedImage对象中，我们只需要将该对象写入到一个图像文件之中，就完成了屏幕到图像的拷贝过程。

### 3.2.3 Java“屏幕照相机”的实现

为了构造一个比较完善的Java屏幕"照相机"，我们构造了一个ImageProvider JavaBean，其源代码和说明如下：

```java
/* 该JavaBean可以直接在其他Java应用程序中调用，实现屏幕的"拍照" */
public class ImageProvider {
private Robot robot=null; //图象采集类
private Rectangle rect=null; //要复制的 屏幕区域
/* 构造函数，输入要采集的屏幕的 矩形信息*/
public ImageProvider() throws AWTException{
rect=new Rectangle(Toolkit.getDefaultToolkit().getScreenSize()); //要复制的屏幕区域，这里为全屏
robot=new Robot(); //创建Robot对象
}
/* 复制全屏幕，返回BufferedImage对象 */
public BufferedImage CopyScreen(){
BufferedImage image=robot.createScreenCapture(rect); //截取屏幕，生成BufferedImage对象
return image;
}
}

```

### 3.2.4 远程屏幕监控的实现

实现屏幕监控要完成被监控端发送屏幕截图和主控端接收图片的工作，该功能的实现中构造了两个类：SendImage Thread和GetImageThread，类图分别为下图。

![](http://www.writebug.com/myres/static/uploads/2021/10/19/d892b27518fbe114d6fb5689946f91b1.writebug)

![](http://www.writebug.com/myres/static/uploads/2021/10/19/b5cf8227cf74a1aabe7086958e1e48ba.writebug)

### 3.2.5 屏幕监视功能测试

在系统实现过程中，成功完成了连续获得被监控端机器屏幕变化的功能，下面为测试图片:

![](http://www.writebug.com/myres/static/uploads/2021/10/19/4d37e0c77c1cfce262eb42de12ddd4cc.writebug)

 本节详细介绍了远程屏幕监视的功能实现。对于功能需求中的其他功能，这里就不逐一介绍了。对于远程控制功能，如果要实现该功能，首先需要主控端向被监控端发送远程控制命令，被监控端收到命令后，首先返回给主控端一个包含被监控端屏幕分辨率等的状态信息，主控端根据状态信息更新本机所存的被控端状态，并调整画布大小，使其比例符合被监控端屏幕分辨率，这样才可以精确定位。在画布中对事件进行监听，采集事件，封装成消息发送给被监控端，然后在被监控端使用Robot对象控制鼠标对象的位置与动作，实现事件重演。这样就能实现远程控制。

# 参考文献

[1] Herbert Schidt.Java 2[M].北京：清华大学出版社

[2] 耿祥义，张跃平.JAVA 2(第二版)[M].北京：清华大学出版社

[3] Bruce Eckel.JAVA编程思想[M].机械工业出版社

[4] 张海藩.软件工程导论[M].北京：清华大学出版社